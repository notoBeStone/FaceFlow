//
//  this file is automatically generated, DO NOT MODIFY IT
//
//  Copyright © 2015 Glority. All rights reserved.
//

import Foundation
import DGMessageAPI

/**
 * 发消息给gpt，gpt会返回消息，text以外的类型需要应用自行支持
 */

public struct ChatbotSendMessageRequest: APIEncodableRequest {
    public typealias Response = ChatbotSendMessageResponse

    public var sessionId: Int64

    public var languageCode: LanguageCode?

    public var countryCode: String?

    public var recordMessage: Bool?

    /**
     * 用户发送的消息内容
     */
    public var messageContents: [MessageContentModel]

    /**
     * 发送message的role，如果没有提供默认为USER，如果提供了，数量需要跟messageContents一致。具体的取值来自MessageFrom的value，之所以不直接使用MessageFrom是因为目前的代码自动生成不支持枚举数组
     */
    public var roles: [Int]?

    /**
     * 模型调用参数，如果未指定，则使用服务端配置的参数
     */
    public var chatArgs: ChatArgsModel?

    /**
     * Json str, 一个简单的json示例: { "type": "json_schema", "json_schema": { "name": "my_response",
 "schema": { "type": "object", "properties": { "reason": {"type": "string"}, "name":
 {"type": "string"} }, "required": ["reason", "name"], "additionalProperties": false },
 "strict": true } }

 <p>详见：https://platform.openai.com/docs/guides/structured-outputs#examples

 <p>如果指定了，就按照这里的格式返回。注意，只有部分模型支持，比如openai gpt-4o，gpt-4o-mini
     */
    public var responseFormat: String?

    /**
     * 本次提问相关itemId（没有就不传）
     */
    public var itemIds: [Int64]?

    /**
     * 本次提问相关itemType（没有就不传）
     */
    public var itemType: String?

    /**
     * 本次提问相关的物种uid（没有就不传）
     */
    public var uid: String?

    public var extraFields:  [String: AnyCodable]?

    enum CodingKeys: String, CodingKey {
        case sessionId = "session_id"

        case languageCode = "language_code"

        case countryCode = "country_code"

        case recordMessage = "record_message"

        case messageContents = "message_contents"

        case roles = "roles"

        case chatArgs = "chat_args"

        case responseFormat = "response_format"

        case itemIds = "item_ids"

        case itemType = "item_type"

        case uid = "uid"

        case extraFields = "extra_fields"
    }
    
    public init(
            sessionId: Int64, 
            languageCode: LanguageCode? = nil, 
            countryCode: String? = nil, 
            recordMessage: Bool? = nil, 
            messageContents: [MessageContentModel], 
            roles: [Int]? = nil, 
            chatArgs: ChatArgsModel? = nil, 
            responseFormat: String? = nil, 
            itemIds: [Int64]? = nil, 
            itemType: String? = nil, 
            uid: String? = nil, 
            extraFields:  [String: AnyCodable]? = nil) {
        self.sessionId = sessionId
        self.languageCode = languageCode
        self.countryCode = countryCode
        self.recordMessage = recordMessage
        self.messageContents = messageContents
        self.roles = roles
        self.chatArgs = chatArgs
        self.responseFormat = responseFormat
        self.itemIds = itemIds
        self.itemType = itemType
        self.uid = uid
        self.extraFields = extraFields
    }
    
    public var api: String {
        "v4/chatbot/send_message"
    }
    
    public var forceHttps: Bool {
        true
    }
    
    public var needAuth: Bool {
        true
    }
    
    public var mustAuth: Bool {
        true
    }
    
    public var methods: [String] {
        ["POST"]
    }
    
    public var mimeBodies: [APIMimeBody] {
        var bodies: [APIMimeBody] = []

        return bodies
    }
    
    public func parseParamater<T>(encoder: T) throws -> T.Output where T : APIEncoder {
        try encoder.encode(self)
    }
}

public struct ChatbotSendMessageResponse: APIJSONResponse {
    /**
     * 根据messageContents组装的用户发送的message（默认情况下只有一条text类型的）
     */
    public var questionMessageList: [MessageModel]

    /**
     * 机器人回复的message（默认情况gpt回复只有一条）
     */
    public var replyMessageList: [MessageModel]

    enum CodingKeys: String, CodingKey {
        case questionMessageList = "question_message_list"

        case replyMessageList = "reply_message_list"
    }

    public init<T>(data: T.Input, decoder: T) throws where T : APIDecoder {
        self = try decoder.decode(ChatbotSendMessageResponse.self, from: data)
    }
}
